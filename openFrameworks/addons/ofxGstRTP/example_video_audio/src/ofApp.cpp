#include "ofApp.h"
#include "ofxNice.h"
#include "ofxGStreamer.h"

//#define BUNDLED

//--------------------------------------------------------------
void ofApp::setup(){
#ifdef BUNDLED
    ofxGStreamerSetBundleEnvironment();
#endif
	ofXml settings;
	settings.load("settings.xml");
	string server = settings.getValue("server");
	string user = settings.getValue("user");
	string pwd = settings.getValue("pwd");

	//ofSetLogLevel(ofxGstRTPServer::LOG_NAME,OF_LOG_VERBOSE);
	//ofSetLogLevel(ofxGstRTPClient::LOG_NAME,OF_LOG_VERBOSE);

	//grabber.setDeviceID(1);
	grabber.initGrabber(640,480);
	remoteVideo.allocate(640,480,GL_RGB);

	ofxNiceEnableDebug();
	rtp.setup(500);
	rtp.setStunServer("132.177.123.6");
	rtp.getXMPP().setCapabilities("telekinect");
	rtp.connectXMPP(server,user,pwd);
	rtp.addSendVideoChannel(640,480,30);
	rtp.addSendAudioChannel();
	calling = -1;

	ofBackground(255);

	ofAddListener(rtp.callReceived,this,&ofApp::onCallReceived);
	ofAddListener(rtp.callFinished,this,&ofApp::onCallFinished);
	ofAddListener(rtp.callAccepted,this,&ofApp::onCallAccepted);

	guiState = 0;
	gui.setup(rtp.parameters,"settings.xml",ofGetWidth()-250,10);
}

void ofApp::onCallReceived(string & from){
	rtp.acceptCall();
}

void ofApp::onCallAccepted(string & from){

}

void ofApp::onCallFinished(ofxXMPPTerminateReason & reason){
}


void ofApp::exit(){
}


//--------------------------------------------------------------
void ofApp::update(){
	grabber.update();
	if(grabber.isFrameNew()){
		rtp.getServer().newFrame(grabber.getPixelsRef());
	}

	rtp.getClient().update();
	if(rtp.getClient().isFrameNewVideo()){
		remoteVideo.loadData(rtp.getClient().getPixelsVideo());
	}
}

//--------------------------------------------------------------
void ofApp::draw(){
	if(guiState==0){
		const vector<ofxXMPPUser> & friends = rtp.getXMPP().getFriends();

		for(size_t i=0;i<friends.size();i++){
			ofSetColor(0);
			if(calling==i){
				if(rtp.getXMPP().getJingleState()==ofxXMPP::SessionAccepted){
					ofSetColor(127);
				}else{
					ofSetColor(ofMap(sin(ofGetElapsedTimef()*2),-1,1,50,127));
				}
				ofRect(ofGetWidth()-300,calling*20+5,300,20);
				ofSetColor(255);
			}
			ofDrawBitmapString(friends[i].userName,ofGetWidth()-250,20+20*i);
			if(friends[i].show==ofxXMPPShowAvailable){
				ofSetColor(ofColor::green);
			}else{
				ofSetColor(ofColor::orange);
			}
			ofCircle(ofGetWidth()-270,20+20*i-5,3);
			//cout << friends[i].userName << endl;
			for(size_t j=0;j<friends[i].capabilities.size();j++){
				if(friends[i].capabilities[j]=="telekinect"){
					ofNoFill();
					ofCircle(ofGetWidth()-270,20+20*i-5,5);
					ofFill();
					break;
				}
			}
		}
	}else{
		gui.draw();
	}

	ofSetColor(255);
	remoteVideo.draw(0,0);
	grabber.draw(400,300,240,180);
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key){
	if(key==OF_KEY_UP){
		guiState++;
		guiState%=2;
	}else if(key==OF_KEY_DOWN){
		guiState--;
		guiState%=2;
	}
}

//--------------------------------------------------------------
void ofApp::keyReleased(int key){

}

//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y ){

}

//--------------------------------------------------------------
void ofApp::mouseDragged(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){
	if(calling==-1){
		ofVec2f mouse(x,y);
		ofRectangle friendsRect(ofGetWidth()-300,0,300,rtp.getXMPP().getFriends().size()*20);
		if(friendsRect.inside(mouse)){
			calling = mouse.y/20;
			rtp.call(rtp.getXMPP().getFriends()[calling]);
		}
	}
}

//--------------------------------------------------------------
void ofApp::mouseReleased(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h){

}

//--------------------------------------------------------------
void ofApp::gotMessage(ofMessage msg){

}

//--------------------------------------------------------------
void ofApp::dragEvent(ofDragInfo dragInfo){ 

}
